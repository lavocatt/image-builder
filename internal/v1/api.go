// Package v1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package v1

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for DistributionProfileItem.
const (
	XccdfOrgSsgprojectContentProfileAnssiBp28Enhanced     DistributionProfileItem = "xccdf_org.ssgproject.content_profile_anssi_bp28_enhanced"
	XccdfOrgSsgprojectContentProfileAnssiBp28High         DistributionProfileItem = "xccdf_org.ssgproject.content_profile_anssi_bp28_high"
	XccdfOrgSsgprojectContentProfileAnssiBp28Intermediary DistributionProfileItem = "xccdf_org.ssgproject.content_profile_anssi_bp28_intermediary"
	XccdfOrgSsgprojectContentProfileAnssiBp28Minimal      DistributionProfileItem = "xccdf_org.ssgproject.content_profile_anssi_bp28_minimal"
	XccdfOrgSsgprojectContentProfileCis                   DistributionProfileItem = "xccdf_org.ssgproject.content_profile_cis"
	XccdfOrgSsgprojectContentProfileCisServerL1           DistributionProfileItem = "xccdf_org.ssgproject.content_profile_cis_server_l1"
	XccdfOrgSsgprojectContentProfileCisWorkstationL1      DistributionProfileItem = "xccdf_org.ssgproject.content_profile_cis_workstation_l1"
	XccdfOrgSsgprojectContentProfileCisWorkstationL2      DistributionProfileItem = "xccdf_org.ssgproject.content_profile_cis_workstation_l2"
	XccdfOrgSsgprojectContentProfileCui                   DistributionProfileItem = "xccdf_org.ssgproject.content_profile_cui"
	XccdfOrgSsgprojectContentProfileE8                    DistributionProfileItem = "xccdf_org.ssgproject.content_profile_e8"
	XccdfOrgSsgprojectContentProfileHipaa                 DistributionProfileItem = "xccdf_org.ssgproject.content_profile_hipaa"
	XccdfOrgSsgprojectContentProfileIsmO                  DistributionProfileItem = "xccdf_org.ssgproject.content_profile_ism_o"
	XccdfOrgSsgprojectContentProfileOspp                  DistributionProfileItem = "xccdf_org.ssgproject.content_profile_ospp"
	XccdfOrgSsgprojectContentProfilePciDss                DistributionProfileItem = "xccdf_org.ssgproject.content_profile_pci-dss"
	XccdfOrgSsgprojectContentProfileStandard              DistributionProfileItem = "xccdf_org.ssgproject.content_profile_standard"
	XccdfOrgSsgprojectContentProfileStig                  DistributionProfileItem = "xccdf_org.ssgproject.content_profile_stig"
	XccdfOrgSsgprojectContentProfileStigGui               DistributionProfileItem = "xccdf_org.ssgproject.content_profile_stig_gui"
)

// Defines values for Distributions.
const (
	Centos8      Distributions = "centos-8"
	Centos9      Distributions = "centos-9"
	Fedora37     Distributions = "fedora-37"
	Fedora38     Distributions = "fedora-38"
	Fedora39     Distributions = "fedora-39"
	Fedora40     Distributions = "fedora-40"
	Rhel8        Distributions = "rhel-8"
	Rhel84       Distributions = "rhel-84"
	Rhel85       Distributions = "rhel-85"
	Rhel86       Distributions = "rhel-86"
	Rhel87       Distributions = "rhel-87"
	Rhel88       Distributions = "rhel-88"
	Rhel8Nightly Distributions = "rhel-8-nightly"
	Rhel9        Distributions = "rhel-9"
	Rhel90       Distributions = "rhel-90"
	Rhel91       Distributions = "rhel-91"
	Rhel92       Distributions = "rhel-92"
	Rhel9Nightly Distributions = "rhel-9-nightly"
)

// Defines values for ImageRequestArchitecture.
const (
	ImageRequestArchitectureAarch64 ImageRequestArchitecture = "aarch64"
	ImageRequestArchitectureX8664   ImageRequestArchitecture = "x86_64"
)

// Defines values for ImageStatusStatus.
const (
	ImageStatusStatusBuilding    ImageStatusStatus = "building"
	ImageStatusStatusFailure     ImageStatusStatus = "failure"
	ImageStatusStatusPending     ImageStatusStatus = "pending"
	ImageStatusStatusRegistering ImageStatusStatus = "registering"
	ImageStatusStatusSuccess     ImageStatusStatus = "success"
	ImageStatusStatusUploading   ImageStatusStatus = "uploading"
)

// Defines values for ImageTypes.
const (
	ImageTypesAmi               ImageTypes = "ami"
	ImageTypesAws               ImageTypes = "aws"
	ImageTypesAzure             ImageTypes = "azure"
	ImageTypesEdgeCommit        ImageTypes = "edge-commit"
	ImageTypesEdgeInstaller     ImageTypes = "edge-installer"
	ImageTypesGcp               ImageTypes = "gcp"
	ImageTypesGuestImage        ImageTypes = "guest-image"
	ImageTypesImageInstaller    ImageTypes = "image-installer"
	ImageTypesRhelEdgeCommit    ImageTypes = "rhel-edge-commit"
	ImageTypesRhelEdgeInstaller ImageTypes = "rhel-edge-installer"
	ImageTypesVhd               ImageTypes = "vhd"
	ImageTypesVsphere           ImageTypes = "vsphere"
	ImageTypesVsphereOva        ImageTypes = "vsphere-ova"
	ImageTypesWsl               ImageTypes = "wsl"
)

// Defines values for UploadStatusStatus.
const (
	UploadStatusStatusFailure UploadStatusStatus = "failure"
	UploadStatusStatusPending UploadStatusStatus = "pending"
	UploadStatusStatusRunning UploadStatusStatus = "running"
	UploadStatusStatusSuccess UploadStatusStatus = "success"
)

// Defines values for UploadTypes.
const (
	UploadTypesAws   UploadTypes = "aws"
	UploadTypesAwsS3 UploadTypes = "aws.s3"
	UploadTypesAzure UploadTypes = "azure"
	UploadTypesGcp   UploadTypes = "gcp"
)

// Defines values for GetPackagesParamsArchitecture.
const (
	GetPackagesParamsArchitectureAarch64 GetPackagesParamsArchitecture = "aarch64"
	GetPackagesParamsArchitectureX8664   GetPackagesParamsArchitecture = "x86_64"
)

// AWSEC2Clone defines model for AWSEC2Clone.
type AWSEC2Clone struct {
	// Region A region as described in
	// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-regions
	Region string `json:"region"`

	// ShareWithAccounts An array of AWS account IDs as described in
	// https://docs.aws.amazon.com/IAM/latest/UserGuide/console_account-alias.html
	ShareWithAccounts *[]string `json:"share_with_accounts,omitempty"`
	ShareWithSources  *[]string `json:"share_with_sources,omitempty"`
}

// AWSS3UploadRequestOptions defines model for AWSS3UploadRequestOptions.
type AWSS3UploadRequestOptions = map[string]interface{}

// AWSS3UploadStatus defines model for AWSS3UploadStatus.
type AWSS3UploadStatus struct {
	Url string `json:"url"`
}

// AWSUploadRequestOptions defines model for AWSUploadRequestOptions.
type AWSUploadRequestOptions struct {
	ShareWithAccounts *[]string `json:"share_with_accounts,omitempty"`
	ShareWithSources  *[]string `json:"share_with_sources,omitempty"`
}

// AWSUploadStatus defines model for AWSUploadStatus.
type AWSUploadStatus struct {
	Ami    string `json:"ami"`
	Region string `json:"region"`
}

// ArchitectureItem defines model for ArchitectureItem.
type ArchitectureItem struct {
	Arch       string   `json:"arch"`
	ImageTypes []string `json:"image_types"`

	// Repositories Base repositories for the given distribution and architecture.
	Repositories []Repository `json:"repositories"`
}

// Architectures defines model for Architectures.
type Architectures = []ArchitectureItem

// AzureUploadRequestOptions defines model for AzureUploadRequestOptions.
type AzureUploadRequestOptions struct {
	// ImageName Name of the created image.
	// Must begin with a letter or number, end with a letter, number or underscore, and may contain only letters, numbers, underscores, periods, or hyphens.
	// The total length is limited to 60 characters.
	ImageName *string `json:"image_name,omitempty"`

	// ResourceGroup Name of the resource group where the image should be uploaded.
	ResourceGroup string `json:"resource_group"`

	// SourceId ID of the source that will be used to resolve the tenant and subscription IDs.
	// Do not provide a tenant_id or subscription_id when providing a source_id.
	SourceId *string `json:"source_id,omitempty"`

	// SubscriptionId ID of subscription where the image should be uploaded.
	// When providing a subscription_id, also be sure to provide a tenant_id and do not include a source_id.
	SubscriptionId *string `json:"subscription_id,omitempty"`

	// TenantId ID of the tenant where the image should be uploaded. This link explains how
	// to find it in the Azure Portal:
	// https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-how-to-find-tenant
	// When providing a tenant_id, also be sure to provide a subscription_id and do not include a source_id.
	TenantId *string `json:"tenant_id,omitempty"`
}

// AzureUploadStatus defines model for AzureUploadStatus.
type AzureUploadStatus struct {
	ImageName string `json:"image_name"`
}

// CloneRequest defines model for CloneRequest.
type CloneRequest struct {
	union json.RawMessage
}

// CloneResponse defines model for CloneResponse.
type CloneResponse struct {
	Id openapi_types.UUID `json:"id"`
}

// ClonesResponse defines model for ClonesResponse.
type ClonesResponse struct {
	Data  []ClonesResponseItem `json:"data"`
	Links struct {
		First string `json:"first"`
		Last  string `json:"last"`
	} `json:"links"`
	Meta struct {
		Count int `json:"count"`
	} `json:"meta"`
}

// ClonesResponseItem defines model for ClonesResponseItem.
type ClonesResponseItem struct {
	// ComposeId UUID of the parent compose of the clone
	ComposeId openapi_types.UUID `json:"compose_id"`
	CreatedAt string             `json:"created_at"`
	Id        openapi_types.UUID `json:"id"`
	Request   CloneRequest       `json:"request"`
}

// ComposeMetadata defines model for ComposeMetadata.
type ComposeMetadata struct {
	// OstreeCommit ID (hash) of the built commit
	OstreeCommit *string `json:"ostree_commit,omitempty"`

	// Packages Package list including NEVRA
	Packages *[]PackageMetadata `json:"packages,omitempty"`
}

// ComposeRequest defines model for ComposeRequest.
type ComposeRequest struct {
	Customizations *Customizations `json:"customizations,omitempty"`

	// Distribution List of all distributions that image builder supports. A user might not have access to
	// restricted distributions.
	//
	// Restricted distributions include the RHEL nightlies and the Fedora distributions.
	Distribution     Distributions `json:"distribution"`
	ImageDescription *string       `json:"image_description,omitempty"`
	ImageName        *string       `json:"image_name,omitempty"`

	// ImageRequests Array of exactly one image request. Having more image requests in one compose is currently not supported.
	ImageRequests []ImageRequest `json:"image_requests"`
}

// ComposeResponse defines model for ComposeResponse.
type ComposeResponse struct {
	Id openapi_types.UUID `json:"id"`
}

// ComposeStatus defines model for ComposeStatus.
type ComposeStatus struct {
	ImageStatus ImageStatus    `json:"image_status"`
	Request     ComposeRequest `json:"request"`
}

// ComposeStatusError defines model for ComposeStatusError.
type ComposeStatusError struct {
	Details *interface{} `json:"details,omitempty"`
	Id      int          `json:"id"`
	Reason  string       `json:"reason"`
}

// ComposesResponse defines model for ComposesResponse.
type ComposesResponse struct {
	Data  []ComposesResponseItem `json:"data"`
	Links struct {
		First string `json:"first"`
		Last  string `json:"last"`
	} `json:"links"`
	Meta struct {
		Count int `json:"count"`
	} `json:"meta"`
}

// ComposesResponseItem defines model for ComposesResponseItem.
type ComposesResponseItem struct {
	CreatedAt string             `json:"created_at"`
	Id        openapi_types.UUID `json:"id"`
	ImageName *string            `json:"image_name,omitempty"`
	Request   ComposeRequest     `json:"request"`
}

// CustomRepository Repository configuration for custom repositories.
// At least one of the 'baseurl', 'mirrorlist', 'metalink' properties must
// be specified. If more of them are specified, the order of precedence is
// the same as listed above. Id is required.
type CustomRepository struct {
	Baseurl      *[]string `json:"baseurl,omitempty"`
	CheckGpg     *bool     `json:"check_gpg,omitempty"`
	CheckRepoGpg *bool     `json:"check_repo_gpg,omitempty"`
	Enabled      *bool     `json:"enabled,omitempty"`
	Filename     *string   `json:"filename,omitempty"`

	// Gpgkey GPG key used to sign packages in this repository. Can be a gpg key or a URL
	Gpgkey     *[]string `json:"gpgkey,omitempty"`
	Id         string    `json:"id"`
	Metalink   *string   `json:"metalink,omitempty"`
	Mirrorlist *string   `json:"mirrorlist,omitempty"`
	Name       *string   `json:"name,omitempty"`
	Priority   *int      `json:"priority,omitempty"`
	SslVerify  *bool     `json:"ssl_verify,omitempty"`
}

// Customizations defines model for Customizations.
type Customizations struct {
	CustomRepositories  *[]CustomRepository `json:"custom_repositories,omitempty"`
	Filesystem          *[]Filesystem       `json:"filesystem,omitempty"`
	Openscap            *OpenSCAP           `json:"openscap,omitempty"`
	Packages            *[]string           `json:"packages,omitempty"`
	PayloadRepositories *[]Repository       `json:"payload_repositories,omitempty"`
	Subscription        *Subscription       `json:"subscription,omitempty"`

	// Users list of users that a customer can add, also specifying their respective groups and SSH keys
	Users *[]User `json:"users,omitempty"`
}

// DistributionItem defines model for DistributionItem.
type DistributionItem struct {
	Description string `json:"description"`
	Name        string `json:"name"`
}

// DistributionProfileItem defines model for DistributionProfileItem.
type DistributionProfileItem string

// DistributionProfileResponse List of profiles for a given distribution
type DistributionProfileResponse = []DistributionProfileItem

// Distributions List of all distributions that image builder supports. A user might not have access to
// restricted distributions.
//
// Restricted distributions include the RHEL nightlies and the Fedora distributions.
type Distributions string

// DistributionsResponse List of distributions this user is allowed to build.
type DistributionsResponse = []DistributionItem

// Filesystem defines model for Filesystem.
type Filesystem struct {
	// MinSize size of the filesystem in bytes
	MinSize    uint64 `json:"min_size"`
	Mountpoint string `json:"mountpoint"`
}

// GCPUploadRequestOptions defines model for GCPUploadRequestOptions.
type GCPUploadRequestOptions struct {
	// ShareWithAccounts List of valid Google accounts to share the imported Compute Node image with.
	// Each string must contain a specifier of the account type. Valid formats are:
	//   - 'user:{emailid}': An email address that represents a specific
	//     Google account. For example, 'alice@example.com'.
	//   - 'serviceAccount:{emailid}': An email address that represents a
	//     service account. For example, 'my-other-app@appspot.gserviceaccount.com'.
	//   - 'group:{emailid}': An email address that represents a Google group.
	//     For example, 'admins@example.com'.
	//   - 'domain:{domain}': The G Suite domain (primary) that represents all
	//     the users of that domain. For example, 'google.com' or 'example.com'.
	//     If not specified, the imported Compute Node image is not shared with any
	//     account.
	ShareWithAccounts *[]string `json:"share_with_accounts,omitempty"`
}

// GCPUploadStatus defines model for GCPUploadStatus.
type GCPUploadStatus struct {
	ImageName string `json:"image_name"`
	ProjectId string `json:"project_id"`
}

// HTTPError defines model for HTTPError.
type HTTPError struct {
	Detail string `json:"detail"`
	Title  string `json:"title"`
}

// HTTPErrorList defines model for HTTPErrorList.
type HTTPErrorList struct {
	Errors []HTTPError `json:"errors"`
}

// ImageRequest defines model for ImageRequest.
type ImageRequest struct {
	// Architecture CPU architecture of the image, x86_64 and aarch64 are currently supported.
	Architecture ImageRequestArchitecture `json:"architecture"`
	ImageType    ImageTypes               `json:"image_type"`
	Ostree       *OSTree                  `json:"ostree,omitempty"`

	// Size Size of image, in bytes. When set to 0 the image size is a minimum
	// defined by the image type.
	Size          *uint64       `json:"size,omitempty"`
	UploadRequest UploadRequest `json:"upload_request"`
}

// ImageRequestArchitecture CPU architecture of the image, x86_64 and aarch64 are currently supported.
type ImageRequestArchitecture string

// ImageStatus defines model for ImageStatus.
type ImageStatus struct {
	Error        *ComposeStatusError `json:"error,omitempty"`
	Status       ImageStatusStatus   `json:"status"`
	UploadStatus *UploadStatus       `json:"upload_status,omitempty"`
}

// ImageStatusStatus defines model for ImageStatus.Status.
type ImageStatusStatus string

// ImageTypes defines model for ImageTypes.
type ImageTypes string

// OSTree defines model for OSTree.
type OSTree struct {
	// Contenturl A URL which, if set, is used for fetching content. Implies that `url` is set as well,
	// which will be used for metadata only.
	Contenturl *string `json:"contenturl,omitempty"`

	// Parent Can be either a commit (example: 02604b2da6e954bd34b8b82a835e5a77d2b60ffa), or a branch-like reference (example: rhel/8/x86_64/edge)
	Parent *string `json:"parent,omitempty"`
	Ref    *string `json:"ref,omitempty"`

	// Rhsm Determines whether a valid subscription manager (candlepin) identity is required to
	// access this repository. Consumer certificates will be used as client certificates when
	// fetching metadata and content.
	Rhsm *bool   `json:"rhsm,omitempty"`
	Url  *string `json:"url,omitempty"`
}

// OpenSCAP defines model for OpenSCAP.
type OpenSCAP struct {
	ProfileId string `json:"profile_id"`
}

// Package defines model for Package.
type Package struct {
	Name    string `json:"name"`
	Summary string `json:"summary"`
}

// PackageMetadata defines model for PackageMetadata.
type PackageMetadata struct {
	Arch      string  `json:"arch"`
	Epoch     *string `json:"epoch,omitempty"`
	Name      string  `json:"name"`
	Release   string  `json:"release"`
	Sigmd5    string  `json:"sigmd5"`
	Signature *string `json:"signature,omitempty"`
	Type      string  `json:"type"`
	Version   string  `json:"version"`
}

// PackagesResponse defines model for PackagesResponse.
type PackagesResponse struct {
	Data  []Package `json:"data"`
	Links struct {
		First string `json:"first"`
		Last  string `json:"last"`
	} `json:"links"`
	Meta struct {
		Count int `json:"count"`
	} `json:"meta"`
}

// Readiness defines model for Readiness.
type Readiness struct {
	Readiness string `json:"readiness"`
}

// Repository defines model for Repository.
type Repository struct {
	Baseurl  *string `json:"baseurl,omitempty"`
	CheckGpg *bool   `json:"check_gpg,omitempty"`

	// CheckRepoGpg Enables gpg verification of the repository metadata
	CheckRepoGpg *bool   `json:"check_repo_gpg,omitempty"`
	Gpgkey       *string `json:"gpgkey,omitempty"`
	IgnoreSsl    *bool   `json:"ignore_ssl,omitempty"`
	Metalink     *string `json:"metalink,omitempty"`
	Mirrorlist   *string `json:"mirrorlist,omitempty"`
	Rhsm         bool    `json:"rhsm"`
}

// Subscription defines model for Subscription.
type Subscription struct {
	ActivationKey string `json:"activation-key"`
	BaseUrl       string `json:"base-url"`
	Insights      bool   `json:"insights"`
	Organization  int    `json:"organization"`

	// Rhc Optional flag to use rhc to register the system, which also always enables Insights.
	Rhc       *bool  `json:"rhc,omitempty"`
	ServerUrl string `json:"server-url"`
}

// UploadRequest defines model for UploadRequest.
type UploadRequest struct {
	Options UploadRequest_Options `json:"options"`
	Type    UploadTypes           `json:"type"`
}

// UploadRequest_Options defines model for UploadRequest.Options.
type UploadRequest_Options struct {
	union json.RawMessage
}

// UploadStatus defines model for UploadStatus.
type UploadStatus struct {
	Options UploadStatus_Options `json:"options"`
	Status  UploadStatusStatus   `json:"status"`
	Type    UploadTypes          `json:"type"`
}

// UploadStatus_Options defines model for UploadStatus.Options.
type UploadStatus_Options struct {
	union json.RawMessage
}

// UploadStatusStatus defines model for UploadStatus.Status.
type UploadStatusStatus string

// UploadTypes defines model for UploadTypes.
type UploadTypes string

// User defines model for User.
type User struct {
	Name   string `json:"name"`
	SshKey string `json:"ssh_key"`
}

// Version defines model for Version.
type Version struct {
	Version string `json:"version"`
}

// GetComposesParams defines parameters for GetComposes.
type GetComposesParams struct {
	// Limit max amount of composes, default 100
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset composes page offset, default 0
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`

	// IgnoreImageTypes Filter the composes on image type. The filter is optional and can be specified multiple times.
	IgnoreImageTypes *[]ImageTypes `form:"ignoreImageTypes,omitempty" json:"ignoreImageTypes,omitempty"`
}

// GetComposeClonesParams defines parameters for GetComposeClones.
type GetComposeClonesParams struct {
	// Limit max amount of clones, default 100
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset clones page offset, default 0
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetPackagesParams defines parameters for GetPackages.
type GetPackagesParams struct {
	// Distribution distribution to look up packages for
	Distribution Distributions `form:"distribution" json:"distribution"`

	// Architecture architecture to look up packages for
	Architecture GetPackagesParamsArchitecture `form:"architecture" json:"architecture"`

	// Search packages to look for
	Search string `form:"search" json:"search"`

	// Limit max amount of packages, default 100
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset packages page offset, default 0
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetPackagesParamsArchitecture defines parameters for GetPackages.
type GetPackagesParamsArchitecture string

// ComposeImageJSONRequestBody defines body for ComposeImage for application/json ContentType.
type ComposeImageJSONRequestBody = ComposeRequest

// CloneComposeJSONRequestBody defines body for CloneCompose for application/json ContentType.
type CloneComposeJSONRequestBody = CloneRequest

// AsAWSEC2Clone returns the union data inside the CloneRequest as a AWSEC2Clone
func (t CloneRequest) AsAWSEC2Clone() (AWSEC2Clone, error) {
	var body AWSEC2Clone
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSEC2Clone overwrites any union data inside the CloneRequest as the provided AWSEC2Clone
func (t *CloneRequest) FromAWSEC2Clone(v AWSEC2Clone) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSEC2Clone performs a merge with any union data inside the CloneRequest, using the provided AWSEC2Clone
func (t *CloneRequest) MergeAWSEC2Clone(v AWSEC2Clone) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t CloneRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CloneRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSUploadRequestOptions returns the union data inside the UploadRequest_Options as a AWSUploadRequestOptions
func (t UploadRequest_Options) AsAWSUploadRequestOptions() (AWSUploadRequestOptions, error) {
	var body AWSUploadRequestOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSUploadRequestOptions overwrites any union data inside the UploadRequest_Options as the provided AWSUploadRequestOptions
func (t *UploadRequest_Options) FromAWSUploadRequestOptions(v AWSUploadRequestOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSUploadRequestOptions performs a merge with any union data inside the UploadRequest_Options, using the provided AWSUploadRequestOptions
func (t *UploadRequest_Options) MergeAWSUploadRequestOptions(v AWSUploadRequestOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAWSS3UploadRequestOptions returns the union data inside the UploadRequest_Options as a AWSS3UploadRequestOptions
func (t UploadRequest_Options) AsAWSS3UploadRequestOptions() (AWSS3UploadRequestOptions, error) {
	var body AWSS3UploadRequestOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSS3UploadRequestOptions overwrites any union data inside the UploadRequest_Options as the provided AWSS3UploadRequestOptions
func (t *UploadRequest_Options) FromAWSS3UploadRequestOptions(v AWSS3UploadRequestOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSS3UploadRequestOptions performs a merge with any union data inside the UploadRequest_Options, using the provided AWSS3UploadRequestOptions
func (t *UploadRequest_Options) MergeAWSS3UploadRequestOptions(v AWSS3UploadRequestOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGCPUploadRequestOptions returns the union data inside the UploadRequest_Options as a GCPUploadRequestOptions
func (t UploadRequest_Options) AsGCPUploadRequestOptions() (GCPUploadRequestOptions, error) {
	var body GCPUploadRequestOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPUploadRequestOptions overwrites any union data inside the UploadRequest_Options as the provided GCPUploadRequestOptions
func (t *UploadRequest_Options) FromGCPUploadRequestOptions(v GCPUploadRequestOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPUploadRequestOptions performs a merge with any union data inside the UploadRequest_Options, using the provided GCPUploadRequestOptions
func (t *UploadRequest_Options) MergeGCPUploadRequestOptions(v GCPUploadRequestOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAzureUploadRequestOptions returns the union data inside the UploadRequest_Options as a AzureUploadRequestOptions
func (t UploadRequest_Options) AsAzureUploadRequestOptions() (AzureUploadRequestOptions, error) {
	var body AzureUploadRequestOptions
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureUploadRequestOptions overwrites any union data inside the UploadRequest_Options as the provided AzureUploadRequestOptions
func (t *UploadRequest_Options) FromAzureUploadRequestOptions(v AzureUploadRequestOptions) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureUploadRequestOptions performs a merge with any union data inside the UploadRequest_Options, using the provided AzureUploadRequestOptions
func (t *UploadRequest_Options) MergeAzureUploadRequestOptions(v AzureUploadRequestOptions) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t UploadRequest_Options) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UploadRequest_Options) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAWSUploadStatus returns the union data inside the UploadStatus_Options as a AWSUploadStatus
func (t UploadStatus_Options) AsAWSUploadStatus() (AWSUploadStatus, error) {
	var body AWSUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSUploadStatus overwrites any union data inside the UploadStatus_Options as the provided AWSUploadStatus
func (t *UploadStatus_Options) FromAWSUploadStatus(v AWSUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided AWSUploadStatus
func (t *UploadStatus_Options) MergeAWSUploadStatus(v AWSUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAWSS3UploadStatus returns the union data inside the UploadStatus_Options as a AWSS3UploadStatus
func (t UploadStatus_Options) AsAWSS3UploadStatus() (AWSS3UploadStatus, error) {
	var body AWSS3UploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAWSS3UploadStatus overwrites any union data inside the UploadStatus_Options as the provided AWSS3UploadStatus
func (t *UploadStatus_Options) FromAWSS3UploadStatus(v AWSS3UploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAWSS3UploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided AWSS3UploadStatus
func (t *UploadStatus_Options) MergeAWSS3UploadStatus(v AWSS3UploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGCPUploadStatus returns the union data inside the UploadStatus_Options as a GCPUploadStatus
func (t UploadStatus_Options) AsGCPUploadStatus() (GCPUploadStatus, error) {
	var body GCPUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGCPUploadStatus overwrites any union data inside the UploadStatus_Options as the provided GCPUploadStatus
func (t *UploadStatus_Options) FromGCPUploadStatus(v GCPUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGCPUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided GCPUploadStatus
func (t *UploadStatus_Options) MergeGCPUploadStatus(v GCPUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsAzureUploadStatus returns the union data inside the UploadStatus_Options as a AzureUploadStatus
func (t UploadStatus_Options) AsAzureUploadStatus() (AzureUploadStatus, error) {
	var body AzureUploadStatus
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAzureUploadStatus overwrites any union data inside the UploadStatus_Options as the provided AzureUploadStatus
func (t *UploadStatus_Options) FromAzureUploadStatus(v AzureUploadStatus) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAzureUploadStatus performs a merge with any union data inside the UploadStatus_Options, using the provided AzureUploadStatus
func (t *UploadStatus_Options) MergeAzureUploadStatus(v AzureUploadStatus) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t UploadStatus_Options) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UploadStatus_Options) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get the architectures and their image types available for a given distribution
	// (GET /architectures/{distribution})
	GetArchitectures(ctx echo.Context, distribution Distributions) error
	// get status of a compose clone
	// (GET /clones/{id})
	GetCloneStatus(ctx echo.Context, id openapi_types.UUID) error
	// compose image
	// (POST /compose)
	ComposeImage(ctx echo.Context) error
	// get a collection of previous compose requests for the logged in user
	// (GET /composes)
	GetComposes(ctx echo.Context, params GetComposesParams) error
	// delete a compose
	// (DELETE /composes/{composeId})
	DeleteCompose(ctx echo.Context, composeId openapi_types.UUID) error
	// get status of an image compose
	// (GET /composes/{composeId})
	GetComposeStatus(ctx echo.Context, composeId openapi_types.UUID) error
	// clone a compose
	// (POST /composes/{composeId}/clone)
	CloneCompose(ctx echo.Context, composeId openapi_types.UUID) error
	// get clones of a compose
	// (GET /composes/{composeId}/clones)
	GetComposeClones(ctx echo.Context, composeId openapi_types.UUID, params GetComposeClonesParams) error
	// get metadata of an image compose
	// (GET /composes/{composeId}/metadata)
	GetComposeMetadata(ctx echo.Context, composeId openapi_types.UUID) error
	// get the distributions available to this user
	// (GET /distributions)
	GetDistributions(ctx echo.Context) error
	// get the openapi json specification
	// (GET /openapi.json)
	GetOpenapiJson(ctx echo.Context) error
	// get the available profiles for a given distribution
	// (GET /oscap/{distribution}/profiles)
	GetOscapProfiles(ctx echo.Context, distribution Distributions) error

	// (GET /packages)
	GetPackages(ctx echo.Context, params GetPackagesParams) error
	// return the readiness
	// (GET /ready)
	GetReadiness(ctx echo.Context) error
	// get the service version
	// (GET /version)
	GetVersion(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetArchitectures converts echo context to params.
func (w *ServerInterfaceWrapper) GetArchitectures(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "distribution" -------------
	var distribution Distributions

	err = runtime.BindStyledParameterWithLocation("simple", false, "distribution", runtime.ParamLocationPath, ctx.Param("distribution"), &distribution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter distribution: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetArchitectures(ctx, distribution)
	return err
}

// GetCloneStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetCloneStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCloneStatus(ctx, id)
	return err
}

// ComposeImage converts echo context to params.
func (w *ServerInterfaceWrapper) ComposeImage(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ComposeImage(ctx)
	return err
}

// GetComposes converts echo context to params.
func (w *ServerInterfaceWrapper) GetComposes(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComposesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "ignoreImageTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "ignoreImageTypes", ctx.QueryParams(), &params.IgnoreImageTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ignoreImageTypes: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetComposes(ctx, params)
	return err
}

// DeleteCompose converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCompose(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "composeId" -------------
	var composeId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "composeId", runtime.ParamLocationPath, ctx.Param("composeId"), &composeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter composeId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCompose(ctx, composeId)
	return err
}

// GetComposeStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetComposeStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "composeId" -------------
	var composeId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "composeId", runtime.ParamLocationPath, ctx.Param("composeId"), &composeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter composeId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetComposeStatus(ctx, composeId)
	return err
}

// CloneCompose converts echo context to params.
func (w *ServerInterfaceWrapper) CloneCompose(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "composeId" -------------
	var composeId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "composeId", runtime.ParamLocationPath, ctx.Param("composeId"), &composeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter composeId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CloneCompose(ctx, composeId)
	return err
}

// GetComposeClones converts echo context to params.
func (w *ServerInterfaceWrapper) GetComposeClones(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "composeId" -------------
	var composeId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "composeId", runtime.ParamLocationPath, ctx.Param("composeId"), &composeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter composeId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetComposeClonesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetComposeClones(ctx, composeId, params)
	return err
}

// GetComposeMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) GetComposeMetadata(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "composeId" -------------
	var composeId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "composeId", runtime.ParamLocationPath, ctx.Param("composeId"), &composeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter composeId: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetComposeMetadata(ctx, composeId)
	return err
}

// GetDistributions converts echo context to params.
func (w *ServerInterfaceWrapper) GetDistributions(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDistributions(ctx)
	return err
}

// GetOpenapiJson converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenapiJson(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOpenapiJson(ctx)
	return err
}

// GetOscapProfiles converts echo context to params.
func (w *ServerInterfaceWrapper) GetOscapProfiles(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "distribution" -------------
	var distribution Distributions

	err = runtime.BindStyledParameterWithLocation("simple", false, "distribution", runtime.ParamLocationPath, ctx.Param("distribution"), &distribution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter distribution: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOscapProfiles(ctx, distribution)
	return err
}

// GetPackages converts echo context to params.
func (w *ServerInterfaceWrapper) GetPackages(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPackagesParams
	// ------------- Required query parameter "distribution" -------------

	err = runtime.BindQueryParameter("form", true, true, "distribution", ctx.QueryParams(), &params.Distribution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter distribution: %s", err))
	}

	// ------------- Required query parameter "architecture" -------------

	err = runtime.BindQueryParameter("form", true, true, "architecture", ctx.QueryParams(), &params.Architecture)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter architecture: %s", err))
	}

	// ------------- Required query parameter "search" -------------

	err = runtime.BindQueryParameter("form", true, true, "search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter search: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPackages(ctx, params)
	return err
}

// GetReadiness converts echo context to params.
func (w *ServerInterfaceWrapper) GetReadiness(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReadiness(ctx)
	return err
}

// GetVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersion(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetVersion(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/architectures/:distribution", wrapper.GetArchitectures)
	router.GET(baseURL+"/clones/:id", wrapper.GetCloneStatus)
	router.POST(baseURL+"/compose", wrapper.ComposeImage)
	router.GET(baseURL+"/composes", wrapper.GetComposes)
	router.DELETE(baseURL+"/composes/:composeId", wrapper.DeleteCompose)
	router.GET(baseURL+"/composes/:composeId", wrapper.GetComposeStatus)
	router.POST(baseURL+"/composes/:composeId/clone", wrapper.CloneCompose)
	router.GET(baseURL+"/composes/:composeId/clones", wrapper.GetComposeClones)
	router.GET(baseURL+"/composes/:composeId/metadata", wrapper.GetComposeMetadata)
	router.GET(baseURL+"/distributions", wrapper.GetDistributions)
	router.GET(baseURL+"/openapi.json", wrapper.GetOpenapiJson)
	router.GET(baseURL+"/oscap/:distribution/profiles", wrapper.GetOscapProfiles)
	router.GET(baseURL+"/packages", wrapper.GetPackages)
	router.GET(baseURL+"/ready", wrapper.GetReadiness)
	router.GET(baseURL+"/version", wrapper.GetVersion)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"asWuKn/5pD2vZT6+f/y/AAAA//8MBBBkEmwAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
